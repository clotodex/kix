{
  description = "Example NixOS module with nested options and autogenerated JSON config";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
    flake-parts.url = "github:hercules-ci/flake-parts";
  };

  outputs =
    inputs@{ flake-parts, ... }:
    flake-parts.lib.mkFlake { inherit inputs; } {
      systems = [
        "x86_64-linux"
        "aarch64-linux"
        "x86_64-darwin"
        "aarch64-darwin"
      ];

      perSystem =
        { pkgs, ... }:
        {
          # Expose the generated config file as an output package for convenience.
          packages = (
            let
              lib = pkgs.lib;
              evaluation = pkgs.lib.evalModules {
                modules = [
                  ./modules
                  ./modules/nginx.nix
                  ./modules/corednsNew
                  #]
                  #++ [
                  #  ./real-config.nix
                ];

                specialArgs = {
                  inherit pkgs;
                  inherit lib;
                  kixlib = import ./lib { inherit pkgs; inherit (pkgs) lib; };
                };

              };

              # We need something that points to all top level components
              manifestsDerivation = pkgs.runCommand "k8s-manifests" { } ''
                mkdir -p $out
                ${lib.concatStringsSep "\n" (
                  lib.mapAttrsToList (
                    _: content: "echo ${content} >> $out/dependencies.txt"
                  ) evaluation.config.manifests
                )}
              '';

            in
            {
              default = manifestsDerivation;

              paths =
                let
                  dependenciesFile = ./dependencies.txt;
                  # Read the initial dependencies
                  dependenciesContent = builtins.readFile dependenciesFile;
                  initialDeps = lib.filter (p: p != "") (lib.splitString "\n" dependenciesContent);

                in
                pkgs.stdenv.mkDerivation {
                  name = "print-all-dependencies";

                  # This is the magic: exportReferencesGraph creates a file with all transitive dependencies
                  #exportReferencesGraph = lib.listToAttrs (
                  #  lib.imap0 (i: dep: {
                  #    name = "graph-${toString i}";
                  #    value = dep;
                  #  }) evaluation.config.manifests
                  #);
                  exportReferencesGraph =   lib.concatLists (lib.mapAttrsToList (name: path: [ "graph-${name}" path ]) evaluation.config.manifests);

                  buildCommand = ''
                    mkdir -p $out

                    # The graph files contain JSON-like data, extract store paths
                    cat graph-* | grep -oE '"/nix/store/[^"]*"' | tr -d '"' | sort -u > all-paths.txt

                    # Now cat all the paths
                    while IFS= read -r path; do
                      if [[ -f "$path" ]]; then
                        echo "=== $path ===" | tee -a $out/all-contents.txt
                        cat "$path" | tee -a $out/all-contents.txt
                        echo "---" | tee -a $out/all-contents.txt
                      fi
                    done < all-paths.txt
                  '';

                };
            }
          );
        };
    };
}

# collect manifests (each module returns an attributeset `manifests` mapping filename -> content-or-path)
# manifests = lib.foldl' (acc: m: acc // (m.config.manifests or { })) { } instantiatedModules;

#manifestsDerivation = pkgs.runCommand "k8s-manifests" { } ''
#  mkdir -p $out
#  ${lib.concatStringsSep "\n" (
#    lib.mapAttrsToList (_: content: "echo ${content} >> $out/dependencies.txt") manifests
#  )}
#'';
