{
  description = "Example NixOS module with nested options and autogenerated JSON config";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
    flake-parts.url = "github:hercules-ci/flake-parts";
  };

  outputs =
    inputs@{ flake-parts, ... }:
    flake-parts.lib.mkFlake { inherit inputs; } {
      systems = [
        "x86_64-linux"
        "aarch64-linux"
        "x86_64-darwin"
        "aarch64-darwin"
      ];

      perSystem =
        { pkgs, ... }:
        {
          # Expose the generated config file as an output package for convenience.
          packages = (
            let
              lib = pkgs.lib;
              evaluation = pkgs.lib.evalModules {
                modules = [
                  ./modules
                  ./modules/nginx.nix
                  ./modules/coredns.nix
                ]
                ++ [
                  ./real-config.nix
                ];

                specialArgs = {
                  inherit pkgs;
                  inherit lib;
                };

              };

              # We need something that points to all top level components
              manifestsDerivation = pkgs.runCommand "k8s-manifests" { } ''
                mkdir -p $out
                ${lib.concatStringsSep "\n" (
                  lib.mapAttrsToList (
                    _: content: "echo ${content} >> $out/dependencies.txt"
                  ) evaluation.config.manifests
                )}
              '';

            in
            {
              default = manifestsDerivation;
            }
          );
        };
    };
}

# collect manifests (each module returns an attributeset `manifests` mapping filename -> content-or-path)
# manifests = lib.foldl' (acc: m: acc // (m.config.manifests or { })) { } instantiatedModules;

#manifestsDerivation = pkgs.runCommand "k8s-manifests" { } ''
#  mkdir -p $out
#  ${lib.concatStringsSep "\n" (
#    lib.mapAttrsToList (_: content: "echo ${content} >> $out/dependencies.txt") manifests
#  )}
#'';
